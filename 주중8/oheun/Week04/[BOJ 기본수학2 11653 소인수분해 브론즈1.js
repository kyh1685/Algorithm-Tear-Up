/*
통과 여부 : 통과
시간 복잡도 : 424 ms
공간 복잡도 :9880 KB

[11653번 소인수분해/브론즈1]
정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오.

input : 정수 N  (1 ≤ N ≤ 10,000,000)
output : 소인수 분해 결과를 한 줄에 하나씩 오름차순으로 출력
예외 : N이 1인 경우 아무것도 출력 x

[개념 잡기]
소인수분해 : 1보다 큰 자연수를 소수인 인수들만의 곱으로 나타내는 것

[문제 풀이]
- 소인수분해 : 소수가 나올 때까지 소수로 나눈다.
    - 가장 작은 소수인 2로 나눈다.
    - 오름차순이므로 for문을 이용해서 작은 수부터 나누어 떨어지는 수까지 반복해서 소인수를 구한다.
    - 정수 N이 1이면 멈춘다.

- 소인수에서 소수로 나누려면?

- 소수 판별 원리 중 가장 효율적인 방법은 해당 숫자의 루트N까지 확인하는 것이다.
    즉, primeFactor에서도 N까지 볼 필요 없다.

[구구 의사코드]
0. 변수 선언
    - 인수를 담을 배열 선언 : factorization
1. 인수 판별
    - 루트 이후에 나오는 인수는 루트 이전 값의 곱이니까 소수가 아니다.
    - 루트 이전에 나누어 떨어지는 인수들을 인수 배열 factorization에 저장한다.

2. 소수 판별
    - factorization 배열을 인덱스 0부터 끝까지 반복 => j로 반복
    - 각 인덱스가 k로 나누었을 때 나머지가 0이라면 소수가 아니다
    - 나누어 떨어지지 않는다면 소수이다 => 출력
 */


/* 
[구 의사코드]
1. N이 1까지 인수분해 되면, 반복문을 멈춘다.
2. N의 약수를 루트 N까지 구하고 배열로 추가한다.
3. 그 배열의 앞쪽 index부터 N을 나누고 나누어 떨어지지 않으면 한 칸씩 옮긴다.

[의사코드 New!]
1. 2부터 N까지 나눈다.
2. 그 중 나누어 떨어지는 값으로 나눈 값을 N에 재할당한다.
3. i--를 하여 다시 그 값으로 나누어지는지 확인한다.
4. 안될시 i++된다.
*/



// 입력값 불러오기
let fs = require('fs');
let N = fs.readFileSync('/dev/stdin').toString().trim(); 
//let N = 72;

for (let i = 2; i <= N; i++) { 
    if(N%i === 0){          // 나누어 떨어진다면 인수이다.
        N = N/i;
        console.log(i);
        i--;
    }
}