/*
통과 여부 :실패...
이유 : 셀프 넘버를 제거할 방법을 잘 모르겠음.
공간 복잡도 :
시간 복잡도 : 

시간제한 : 1초
메모리 제한 256MB


문제 : [BOJ] 4673 셀프 넘버(생성자가 없는 순서)
함수 d를 정의하여 문제를 해결해 봅시다.
d(n) => 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수
n => 생성자
ex) d(75) = 75 + 7 + 5 = 87

input : X
output : 셀프 넘버를 한 줄에 하나씩 증가하는 순서(< 10,000)
*/


/*
** 아이디어
1) 입력이 없기 때문에 매개변수는 없다.
2) 생성자가 없는 셀프 넘버를 출력해야 하므로 d함수의 결과를 제거해야 한다.
3) 양의 정수이므로 1<n<10000 사이의 반복문이다.
4) d(n)을 했을 때 무한 수열이 나오게 된다. d(n)이라는 함수에는 입력이 들어간다. 반복문 안에서 함수 실행?
5) 일의 자리는 본인 * 2는 셀프 넘버가 아니다

** 의사코드
# Math를 사용할 때
1. 결과 result 변수 선언하고, n을 할당한다.
2. n>0보다 클 때까지 do while문 실행
    2.1. n%10 즉, 나머지를 result에 더한다.
    2.2. n/10한 값을 n에 저장함으로써 뒷 자릿수를 하나씩 제거한다.
3. 결과값을 다시 d(result)로 넣어 다음 값을 구한다.
    

1. 자릿수를 확인한다
2. 자릿수만큼 나눠서 나머지를 확인해야 한다.
3. n + Math.floor(n/10)+Math.floor(n) 어찌해야하지?

해당 자리가 존재하지 않는다면 0으로 처리된다.
*/

/*
틀린 이유
ex) 111의 경우, parseInt(n/10)을 하게 되면 11이 나오기 때문에

=> do while문을 사용해서 자릿수마다 제거
*/

let result = 0;

function d(n){
    result = n;                 // result에 n을 할당한다.
    // 테스트 조건이 거짓이 될 때까지 구문을 실행한다.
    do {
        result += n%10;         // n의 나머지
        n = Math.floor(n/10);   // 시행할 때마다 뒤쪽 자릿수가 줄어든다. 1234 -> 123 -> 12...

    }while(n>0);
    console.log(result);
    if(result < 9993){
    d(result);}
}

// for문 써서 전체 볼 수 있음.
d(33);

// 이제 d(n)에 해당되는 내용을 제거하면 됨.
// 재귀적으로 사용하면 좋을 것
// 중복 제거 - 어떻게??