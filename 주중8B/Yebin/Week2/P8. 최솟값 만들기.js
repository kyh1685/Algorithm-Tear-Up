/**
채점을 시작합니다.
정확성  테스트
테스트 1 〉	통과 (0.06ms, 33.5MB)
테스트 2 〉	통과 (0.20ms, 33.5MB)
테스트 3 〉	통과 (0.18ms, 33.5MB)
테스트 4 〉	통과 (0.19ms, 33.5MB)
테스트 5 〉	통과 (0.19ms, 33.5MB)
테스트 6 〉	통과 (0.20ms, 33.5MB)
테스트 7 〉	통과 (0.20ms, 33.4MB)
테스트 8 〉	통과 (0.20ms, 33.5MB)
테스트 9 〉	통과 (0.19ms, 33.5MB)
테스트 10 〉	통과 (0.19ms, 33.6MB)
테스트 11 〉	통과 (0.24ms, 33.4MB)
테스트 12 〉	통과 (0.17ms, 33.6MB)
테스트 13 〉	통과 (0.17ms, 33.5MB)
테스트 14 〉	통과 (0.17ms, 33.5MB)
테스트 15 〉	통과 (0.17ms, 33.5MB)
테스트 16 〉	통과 (0.17ms, 33.4MB)
효율성  테스트
테스트 1 〉	통과 (0.73ms, 33.4MB)
테스트 2 〉	통과 (0.77ms, 33.5MB)
테스트 3 〉	통과 (0.80ms, 33MB)
테스트 4 〉	통과 (1.21ms, 32.9MB)
채점 결과
정확성: 69.6
효율성: 30.4
합계: 100.0 / 100.0
 */

// 누적값이 최소가 되게 하려면 A배열의 최솟값과 B배열의 최댓값, B배열의 최솟값과 A배열의 최댓값이 곱해져야 함
function solution(A, B) {
  // A 오름차순 정렬
  const sortedA = A.sort((a, b) => a - b);
  // B 내림차순 정렬
  const sortedB = B.sort((a, b) => b - a);
  let result = sortedA
    .map((el, idx) => el * sortedB[idx])
    .reduce((a, b) => a + b, 0);
  return result;
}
